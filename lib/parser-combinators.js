// Generated by LiveScript 1.2.0
/* LiveScript requires explicit importing of function names! */
(function(){
  var ref$, isType, keys, values, head, map, zip, filter, sys, say, print, Dumper, V, sequence, bind, enter, choice, tryParse, maybe, parens, parseChar, sepBy, word, natural, symbol, many, many1, comma, semi, whiteSpace, oneOf, regex, get_tree_as_lists, is_list_of_objects, l2m, getParseTree;
  ref$ = require('prelude-ls'), isType = ref$.isType, keys = ref$.keys, values = ref$.values, head = ref$.head, map = ref$.map, zip = ref$.zip, filter = ref$.filter;
  sys = require('sys');
  say = function(x){
    return process.stdout.write(x + "\n");
  };
  print = function(x){
    return process.stdout.write(x);
  };
  Dumper = function(x){
    return sys.inspect(x);
  };
  V = 0;
  sequence = function(plst, proc){
    var gen;
    gen = function(str){
      var matches, st, str2, ms, i$, ref$, len$, p, ref1$, k, pp, mms, p2;
      if (V) {
        say("* sequence( '" + str + "' )");
      }
      matches = [];
      st = 1;
      str2 = '';
      ms = [];
      for (i$ = 0, len$ = (ref$ = plst).length; i$ < len$; ++i$) {
        p = ref$[i$];
        if (typeof p === 'function') {
          ref1$ = p(str), st = ref1$[0], str = ref1$[1], ms = ref1$[2];
        } else if (!isType('Array', p)) {
          k = head(keys(p));
          pp = p[k];
          ref1$ = pp(str), st = ref1$[0], str = ref1$[1], mms = ref1$[2];
          ms = {};
          ms[k] = mms;
        } else {
          p2 = sequence(p);
          ref1$ = p2(str), st = ref1$[0], str = ref1$[1], ms = ref1$[2];
        }
        if (!st) {
          return [0, str, void 8];
        }
        matches.push(ms);
      }
      if (proc !== undefined) {
        if (typeof proc === 'function') {
          return [1, str, proc(matches)];
        } else {
          return [1, str, matches];
        }
      } else {
        return [1, str, matches];
      }
    };
    return gen;
  };
  bind = function(p1, p2){
    var gen;
    gen = function(str1){
      var matches, ref$, st1, m1, str2, st2, m2, str3;
      matches = [];
      ref$ = p1(str1), st1 = ref$[0], m1 = ref$[1], str2 = ref$[2];
      matches.push(m1);
      if (st1 === 1) {
        ref$ = p2(str2), st2 = ref$[0], m2 = ref$[1], str3 = ref$[2];
        matches.push(m2);
        return [st2, str3, matches];
      } else {
        return [0, str1, void 8];
      }
    };
    return gen;
  };
  enter = function(str){
    return [0, str, void 8];
  };
  choice = function(parsers){
    var gen;
    gen = function(str){
      var i$, ref$, len$, p, status, matches, ref1$, k, pp, mms;
      if (V) {
        say("* choice( '" + str + "' )");
      }
      for (i$ = 0, len$ = (ref$ = parsers).length; i$ < len$; ++i$) {
        p = ref$[i$];
        status = 0;
        matches = [];
        if (typeof p === 'function') {
          ref1$ = p(str), status = ref1$[0], str = ref1$[1], matches = ref1$[2];
        } else if (!isType('Array', p)) {
          k = head(keys(p));
          pp = p[k];
          ref1$ = pp(str), status = ref1$[0], str = ref1$[1], mms = ref1$[2];
          matches = {};
          matches[k] = mms;
        } else {
          say('ARRAY');
        }
        if (status) {
          if (V) {
            say("choice: remainder : <" + str + ">");
          }
          if (V) {
            say("choice: matches : [".concat(matches, "]"));
          }
          return [status, str, matches];
        }
      }
      return [0, str, void 8];
    };
    return gen;
  };
  tryParse = function(p){
    var gen;
    gen = function(str){
      var ref$, status, rest, matches;
      if (V) {
        say("* try('" + str + "')");
      }
      ref$ = p(str), status = ref$[0], rest = ref$[1], matches = ref$[2];
      if (status) {
        if (V) {
          say("try: remainder => <" + rest + ">");
        }
        if (V) {
          say("try: matches => [" + matches + "]");
        }
        return [1, rest, matches];
      } else {
        if (V) {
          say("try: no matches => <" + str + ">");
        }
        return [0, str, matches];
      }
    };
    return gen;
  };
  maybe = function(p){
    var gen;
    gen = function(str){
      var ref$, status, rest, matches;
      if (V) {
        say("* maybe('" + str + "')");
      }
      ref$ = p(str), status = ref$[0], rest = ref$[1], matches = ref$[2];
      if (status) {
        if (V) {
          say("maybe matches: [".concat(matches, "]"));
        }
        return [1, rest, matches];
      } else {
        if (V) {
          say("maybe: no matches for <" + str + ">");
        }
        return [1, str, void 8];
      }
    };
    return gen;
  };
  parens = function(p){
    var gen;
    gen = function(str0){
      var matches, ref$, status, str3, ch, str4, st, str4s, str5, str6;
      if (V) {
        say("* parens( '" + str0 + "' )");
      }
      matches = [];
      ref$ = parseChar('(')(str0), status = ref$[0], str3 = ref$[1], ch = ref$[2];
      if (status) {
        str4 = str3.replace(/^\s*/, '');
        ref$ = p(str4), st = ref$[0], str4s = ref$[1], matches = ref$[2];
        if (V) {
          say("parens: remainder => <" + str4s + ">\n");
        }
        if (V) {
          say("parens: matches => " + sys.inspect(matches) + "\n");
        }
        status *= st;
        if (status === 1) {
          ref$ = parseChar(')')(str4s), st = ref$[0], str5 = ref$[1], ch = ref$[2];
          status *= st;
          if (status === 1) {
            str6 = str5.replace(/^\s*/, '');
            if (V) {
              say("parens: remainder => <" + str5 + ">\n");
            }
            if (V) {
              say("parens: closing matches => " + sys.inspect(matches) + "\n");
            }
            return [1, str6, matches];
          } else {
            return [0, str5, matches];
          }
        } else {
          return [0, str4, matches];
        }
      } else {
        return [0, str3, void 8];
      }
    };
    return gen;
  };
  parseChar = function(ch){
    var gen;
    gen = function(str0){
      if (V) {
        say("* parseChar('" + ch + "', '" + str0 + "' )");
      }
      if (str0.substring(0, 1) === ch) {
        if (V) {
          say(("parseChar: '" + ch + "' in <" + str0 + "> => ") + str0.substring(1) + "\n");
        }
        return [1, str0.substring(1), ch];
      } else {
        return [0, str0, void 8];
      }
    };
    return gen;
  };
  sepBy = function(sep, p){
    var gen;
    gen = function(str0){
      var matches, ref$, status, str1, m, str2, str2s, st, str3;
      matches = [];
      if (V) {
        say("* sepBy( '" + sep + "', '" + str0 + "' )");
      }
      ref$ = p(str0), status = ref$[0], str1 = ref$[1], m = ref$[2];
      if (status) {
        matches.push(m);
        if (V) {
          say("sepBy: remainder : <" + str1 + ">");
        }
        ref$ = parseChar(sep)(str1), status = ref$[0], str2 = ref$[1], m = ref$[2];
        while (status) {
          str2s = str2.replace(/^\s*/, '');
          ref$ = p(str2s), st = ref$[0], str3 = ref$[1], m = ref$[2];
          matches.push(m);
          ref$ = parseChar(sep)(str3), status = ref$[0], str2 = ref$[1], m = ref$[2];
        }
        if (V) {
          say("sepBy matches : [".concat(matches, "]"));
        }
        return [1, str2, matches];
      } else {
        return [0, str1, void 8];
      }
    };
    return gen;
  };
  word = function(str){
    var status, matches, m, str2;
    if (V) {
      say("* word( '" + str + "' )");
    }
    status = 0;
    matches = void 8;
    if (str.match(/^(\w+)/)) {
      m = str.match(/^(\w+)/)[1];
      matches = m;
      status = 1;
      str2 = str.replace(/^\w+\s*/, '');
      if (V) {
        say("word: remainder : <" + str2 + ">");
      }
      if (V) {
        say('word: matches : ['.concat(matches, "]"));
      }
      return [status, str2, matches];
    } else {
      if (V) {
        say("word: match failed : <str>");
      }
      return [status, str, matches];
    }
  };
  natural = function(str){
    var status, matches, m, str2;
    if (V) {
      say("* natural( '" + str + "' )");
    }
    status = 0;
    matches = void 8;
    if (str.match(/^(\d+)/)) {
      m = str.match(/^(\d+)/)[1];
      matches = m;
      status = 1;
      str2 = str.replace(/^\d+\s*/, '');
      if (V) {
        say("natural: remainder : <" + str2 + ">");
      }
      if (V) {
        say('natural: matches : ['.concat(matches, "]"));
      }
      return [status, str2, matches];
    } else {
      if (V) {
        say("natural: match failed : <str>");
      }
      return [status, str, matches];
    }
  };
  symbol = function(lit_str){
    var lit_str_esc, gen;
    lit_str_esc = lit_str.replace(/(\W)/g, '\\$1');
    gen = function(str){
      var status, matches, re, str2;
      if (V) {
        say("* symbol('" + lit_str + "', '" + str + "' )");
      }
      status = 0;
      matches = void 8;
      re = new RegExp('^' + lit_str_esc + '\\s*');
      if (str.match(re)) {
        matches = lit_str;
        status = 1;
        str2 = str.replace(re, '');
        if (V) {
          say("symbol: remainder : <".concat(str2, ">"));
        }
        if (V) {
          say('symbol: matches : ['.concat(matches, "]"));
        }
        return [status, str2, matches];
      } else {
        if (V) {
          say("symbol: match failed : <" + str + ">");
        }
        return [status, str, matches];
      }
    };
    return gen;
  };
  many = function(parser){
    var gen;
    gen = function(str){
      var matches, ref$, status, m, st;
      matches = [];
      if (V) {
        say("* many( '" + str + "' )");
      }
      ref$ = parser(str), status = ref$[0], str = ref$[1], m = ref$[2];
      if (status) {
        matches.push(m);
        while (status === 1) {
          ref$ = parser(str), st = ref$[0], str = ref$[1], m = ref$[2];
          matches.push(m);
        }
        if (V) {
          say("many: remainder : <str>");
        }
        if (V) {
          say("many: matches : [".concat(matches, "]"));
        }
      } else {
        if (V) {
          say("many: first match failed : <str>");
        }
        return [1, str, void 8];
      }
      return [1, str, matches];
    };
    return gen;
  };
  many1 = function(parser){
    var gen;
    gen = function(str){
      var matches, ref$, status, m, st;
      matches = [];
      if (V) {
        say("* many1( '" + str + "' )");
      }
      ref$ = parser(str), status = ref$[0], str = ref$[1], m = ref$[2];
      if (status) {
        matches.push(m);
        if (V) {
          say("many11: status : <str>");
        }
        while (status === 1) {
          ref$ = parser(str), st = ref$[0], str = ref$[1], m = ref$[2];
          matches.push(m);
        }
        if (V) {
          say("many1: remainder : <str>");
        }
        if (V) {
          say("many1: matches : [".concat(matches, "]"));
        }
      } else {
        if (V) {
          say("many1: first match failed : <str>");
        }
        return [0, str, void 8];
      }
      return [1, str, matches];
    };
    return gen;
  };
  comma = function(str){
    var st, ref$, str2;
    if (V) {
      say("* comma( '" + str + "' )");
    }
    st = (ref$ = str.match(/^\s*,\s*/)) != null
      ? ref$
      : {
        1: 0
      };
    str2 = str.replace(/^\s*,\s*/, '');
    return [st, str2, void 8];
  };
  semi = function(str){
    var st, ref$, str2;
    if (V) {
      say("* semi( '" + str + "' )");
    }
    st = (ref$ = str.match(/^\s*,\s*/)) != null
      ? ref$
      : {
        1: 0
      };
    str2 = str.replace(/^\s*;\s*/, '');
    return [st, str2, void 8];
  };
  whiteSpace = function(str){
    var ms, ref$, str2;
    if (V) {
      say("* whiteSpace( '" + str + "' )");
    }
    ms = (ref$ = str.match(/^\s*/)) != null
      ? ref$
      : {
        1: 0
      };
    str2 = str.replace(/^\s*/, '');
    return [1, str2, ms[0]];
  };
  oneOf = function(patt_lst){
    var gen;
    gen = function(str){
      var i$, ref$, len$, p, ref1$, status, matches;
      if (V) {
        say("* oneOf( [".concat(patt_lst, "], '" + str + "' )"));
      }
      for (i$ = 0, len$ = (ref$ = patt_lst).length; i$ < len$; ++i$) {
        p = ref$[i$];
        ref1$ = symbol(p)(str), status = ref1$[0], str = ref1$[1], matches = ref1$[2];
        if (status) {
          if (V) {
            say("choice: remainder : <str>");
          }
          if (V) {
            say("choice: matches : [".concat(matches, "]"));
          }
          return [status, str, matches];
        }
      }
      return [0, str, void 8];
    };
    return gen;
  };
  regex = function(regexstr){
    var gen;
    gen = function(str){
      var re, m, str2, matches;
      if (V) {
        say("* regex( '/" + regexstr + "/', '" + str + "' )");
      }
      re = new RegExp('(' + regexstr + ')\\s*');
      if (str.match(re)) {
        m = str.match(re)[1];
        str2 = str.replace(re, '');
        matches = m;
        if (V) {
          say("regex: remainder => <" + str2 + ">");
        }
        if (V) {
          say("regex: matches => [" + matches + "]");
        }
        return [1, str2, matches];
      } else {
        if (V) {
          say("regex: match failed => <" + str + ">\n");
        }
        return [0, str, void 8];
      }
    };
    return gen;
  };
  get_tree_as_lists = function(list){
    var hlist, i$, len$, elt, k, v, kv, pv, kpv;
    hlist = [];
    for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
      elt = list[i$];
      if (V) {
        say("ELT: <" + elt + ">");
      }
      if (isType('Array', elt) && elt.length > 0) {
        hlist.push(get_tree_as_lists(elt));
      } else if (isType('Object', elt)) {
        k = head(keys(elt));
        v = elt[k];
        if (V) {
          say("HASH: " + k + " => " + v);
        }
        if (!isType('Array', v)) {
          if (V) {
            say('    NOT ARRAY => just push');
          }
          kv = {};
          kv[k] = v;
          hlist.push(kv);
        } else if (v.length === 1) {
          if (V) {
            say('    SINGLE-ELT ARRAY');
          }
          kv = {};
          kv[k] = head(v);
          hlist.push(kv);
        } else {
          if (V) {
            say('    ARRAY');
          }
          pv = map(fn$, v);
          kpv = {};
          kpv[k] = pv;
          hlist.push(kpv);
        }
      } else {
        if (V) {
          say("SKIP: " + elt);
        }
      }
    }
    if (hlist.length === 1) {
      return head(hlist);
    } else {
      return hlist;
    }
    function fn$(x){
      switch (false) {
      case !isType('Array', x):
        return get_tree_as_lists(x);
      case !isType('Object', x):
        return get_tree_as_lists([x]);
      case !!isType('Undefined', x):
        return x;
      }
    }
  };
  is_list_of_objects = function(mlo){
    var to, l;
    to = function(x){
      return !isType('Object', x);
    };
    l = filter(to, mlo);
    return l.length === 0;
  };
  l2m = function(hlist){
    var hmap, hmap_keys, hmap_vals, vl2m, hmap_kvs, tf;
    hmap = {};
    hmap_keys = map(function(){
      return head(keys.apply(this, arguments));
    }, hlist);
    hmap_vals = map(function(){
      return head(values.apply(this, arguments));
    }, hlist);
    vl2m = function(h){
      if (is_list_of_objects(h)) {
        return l2m(h);
      } else {
        return h;
      }
    };
    hmap_kvs = zip(hmap_keys, map(vl2m, hmap_vals));
    tf = function(kv){
      return hmap[kv[0]] = kv[1];
    };
    map(tf, hmap_kvs);
    return hmap;
  };
  getParseTree = function(m){
    return l2m(get_tree_as_lists(m));
  };
  module.exports = {
    sequence: sequence,
    choice: choice,
    tryParse: tryParse,
    maybe: maybe,
    oneOf: oneOf,
    parens: parens,
    parseChar: parseChar,
    sepBy: sepBy,
    word: word,
    natural: natural,
    symbol: symbol,
    comma: comma,
    semi: semi,
    many: many,
    many1: many1,
    whiteSpace: whiteSpace,
    regex: regex,
    getParseTree: getParseTree,
    say: say,
    print: print,
    Dumper: Dumper
  };
}).call(this);
